// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: client.proto

#include "client.pb.h"
#include "client.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace krclient {

static const char* KrCoreApi_method_names[] = {
  "/krclient.KrCoreApi/CancelTask",
  "/krclient.KrCoreApi/EmitCommand",
  "/krclient.KrCoreApi/Packer",
  "/krclient.KrCoreApi/TaskCloseWindow",
  "/krclient.KrCoreApi/TaskDumpStart",
  "/krclient.KrCoreApi/UniversalDumper",
  "/krclient.KrCoreApi/UniversalPatch",
};

std::unique_ptr< KrCoreApi::Stub> KrCoreApi::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< KrCoreApi::Stub> stub(new KrCoreApi::Stub(channel, options));
  return stub;
}

KrCoreApi::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_CancelTask_(KrCoreApi_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_EmitCommand_(KrCoreApi_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Packer_(KrCoreApi_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_TaskCloseWindow_(KrCoreApi_method_names[3], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_TaskDumpStart_(KrCoreApi_method_names[4], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_UniversalDumper_(KrCoreApi_method_names[5], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_UniversalPatch_(KrCoreApi_method_names[6], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status KrCoreApi::Stub::CancelTask(::grpc::ClientContext* context, const ::krclient::CancelTaskRequest& request, ::krclient::CancelTaskResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::krclient::CancelTaskRequest, ::krclient::CancelTaskResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_CancelTask_, context, request, response);
}

void KrCoreApi::Stub::async::CancelTask(::grpc::ClientContext* context, const ::krclient::CancelTaskRequest* request, ::krclient::CancelTaskResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::krclient::CancelTaskRequest, ::krclient::CancelTaskResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_CancelTask_, context, request, response, std::move(f));
}

void KrCoreApi::Stub::async::CancelTask(::grpc::ClientContext* context, const ::krclient::CancelTaskRequest* request, ::krclient::CancelTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_CancelTask_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::krclient::CancelTaskResponse>* KrCoreApi::Stub::PrepareAsyncCancelTaskRaw(::grpc::ClientContext* context, const ::krclient::CancelTaskRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::krclient::CancelTaskResponse, ::krclient::CancelTaskRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_CancelTask_, context, request);
}

::grpc::ClientAsyncResponseReader< ::krclient::CancelTaskResponse>* KrCoreApi::Stub::AsyncCancelTaskRaw(::grpc::ClientContext* context, const ::krclient::CancelTaskRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncCancelTaskRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status KrCoreApi::Stub::EmitCommand(::grpc::ClientContext* context, const ::krclient::EmitCommandRequest& request, ::krclient::EmitCommandResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::krclient::EmitCommandRequest, ::krclient::EmitCommandResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_EmitCommand_, context, request, response);
}

void KrCoreApi::Stub::async::EmitCommand(::grpc::ClientContext* context, const ::krclient::EmitCommandRequest* request, ::krclient::EmitCommandResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::krclient::EmitCommandRequest, ::krclient::EmitCommandResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_EmitCommand_, context, request, response, std::move(f));
}

void KrCoreApi::Stub::async::EmitCommand(::grpc::ClientContext* context, const ::krclient::EmitCommandRequest* request, ::krclient::EmitCommandResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_EmitCommand_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::krclient::EmitCommandResponse>* KrCoreApi::Stub::PrepareAsyncEmitCommandRaw(::grpc::ClientContext* context, const ::krclient::EmitCommandRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::krclient::EmitCommandResponse, ::krclient::EmitCommandRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_EmitCommand_, context, request);
}

::grpc::ClientAsyncResponseReader< ::krclient::EmitCommandResponse>* KrCoreApi::Stub::AsyncEmitCommandRaw(::grpc::ClientContext* context, const ::krclient::EmitCommandRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncEmitCommandRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status KrCoreApi::Stub::Packer(::grpc::ClientContext* context, const ::krclient::PackerRequest& request, ::krclient::PackerResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::krclient::PackerRequest, ::krclient::PackerResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Packer_, context, request, response);
}

void KrCoreApi::Stub::async::Packer(::grpc::ClientContext* context, const ::krclient::PackerRequest* request, ::krclient::PackerResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::krclient::PackerRequest, ::krclient::PackerResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Packer_, context, request, response, std::move(f));
}

void KrCoreApi::Stub::async::Packer(::grpc::ClientContext* context, const ::krclient::PackerRequest* request, ::krclient::PackerResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Packer_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::krclient::PackerResponse>* KrCoreApi::Stub::PrepareAsyncPackerRaw(::grpc::ClientContext* context, const ::krclient::PackerRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::krclient::PackerResponse, ::krclient::PackerRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Packer_, context, request);
}

::grpc::ClientAsyncResponseReader< ::krclient::PackerResponse>* KrCoreApi::Stub::AsyncPackerRaw(::grpc::ClientContext* context, const ::krclient::PackerRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncPackerRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status KrCoreApi::Stub::TaskCloseWindow(::grpc::ClientContext* context, const ::krclient::TaskCloseWindowRequest& request, ::krclient::TaskCloseWindowResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::krclient::TaskCloseWindowRequest, ::krclient::TaskCloseWindowResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_TaskCloseWindow_, context, request, response);
}

void KrCoreApi::Stub::async::TaskCloseWindow(::grpc::ClientContext* context, const ::krclient::TaskCloseWindowRequest* request, ::krclient::TaskCloseWindowResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::krclient::TaskCloseWindowRequest, ::krclient::TaskCloseWindowResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_TaskCloseWindow_, context, request, response, std::move(f));
}

void KrCoreApi::Stub::async::TaskCloseWindow(::grpc::ClientContext* context, const ::krclient::TaskCloseWindowRequest* request, ::krclient::TaskCloseWindowResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_TaskCloseWindow_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::krclient::TaskCloseWindowResponse>* KrCoreApi::Stub::PrepareAsyncTaskCloseWindowRaw(::grpc::ClientContext* context, const ::krclient::TaskCloseWindowRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::krclient::TaskCloseWindowResponse, ::krclient::TaskCloseWindowRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_TaskCloseWindow_, context, request);
}

::grpc::ClientAsyncResponseReader< ::krclient::TaskCloseWindowResponse>* KrCoreApi::Stub::AsyncTaskCloseWindowRaw(::grpc::ClientContext* context, const ::krclient::TaskCloseWindowRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncTaskCloseWindowRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status KrCoreApi::Stub::TaskDumpStart(::grpc::ClientContext* context, const ::krclient::TaskDumpStartRequest& request, ::krclient::TaskDumpStartResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::krclient::TaskDumpStartRequest, ::krclient::TaskDumpStartResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_TaskDumpStart_, context, request, response);
}

void KrCoreApi::Stub::async::TaskDumpStart(::grpc::ClientContext* context, const ::krclient::TaskDumpStartRequest* request, ::krclient::TaskDumpStartResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::krclient::TaskDumpStartRequest, ::krclient::TaskDumpStartResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_TaskDumpStart_, context, request, response, std::move(f));
}

void KrCoreApi::Stub::async::TaskDumpStart(::grpc::ClientContext* context, const ::krclient::TaskDumpStartRequest* request, ::krclient::TaskDumpStartResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_TaskDumpStart_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::krclient::TaskDumpStartResponse>* KrCoreApi::Stub::PrepareAsyncTaskDumpStartRaw(::grpc::ClientContext* context, const ::krclient::TaskDumpStartRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::krclient::TaskDumpStartResponse, ::krclient::TaskDumpStartRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_TaskDumpStart_, context, request);
}

::grpc::ClientAsyncResponseReader< ::krclient::TaskDumpStartResponse>* KrCoreApi::Stub::AsyncTaskDumpStartRaw(::grpc::ClientContext* context, const ::krclient::TaskDumpStartRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncTaskDumpStartRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status KrCoreApi::Stub::UniversalDumper(::grpc::ClientContext* context, const ::krclient::UniversalDumperRequest& request, ::krclient::UniversalDumperResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::krclient::UniversalDumperRequest, ::krclient::UniversalDumperResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_UniversalDumper_, context, request, response);
}

void KrCoreApi::Stub::async::UniversalDumper(::grpc::ClientContext* context, const ::krclient::UniversalDumperRequest* request, ::krclient::UniversalDumperResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::krclient::UniversalDumperRequest, ::krclient::UniversalDumperResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_UniversalDumper_, context, request, response, std::move(f));
}

void KrCoreApi::Stub::async::UniversalDumper(::grpc::ClientContext* context, const ::krclient::UniversalDumperRequest* request, ::krclient::UniversalDumperResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_UniversalDumper_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::krclient::UniversalDumperResponse>* KrCoreApi::Stub::PrepareAsyncUniversalDumperRaw(::grpc::ClientContext* context, const ::krclient::UniversalDumperRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::krclient::UniversalDumperResponse, ::krclient::UniversalDumperRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_UniversalDumper_, context, request);
}

::grpc::ClientAsyncResponseReader< ::krclient::UniversalDumperResponse>* KrCoreApi::Stub::AsyncUniversalDumperRaw(::grpc::ClientContext* context, const ::krclient::UniversalDumperRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncUniversalDumperRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status KrCoreApi::Stub::UniversalPatch(::grpc::ClientContext* context, const ::krclient::UniversalPatchRequest& request, ::krclient::UniversalPatchResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::krclient::UniversalPatchRequest, ::krclient::UniversalPatchResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_UniversalPatch_, context, request, response);
}

void KrCoreApi::Stub::async::UniversalPatch(::grpc::ClientContext* context, const ::krclient::UniversalPatchRequest* request, ::krclient::UniversalPatchResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::krclient::UniversalPatchRequest, ::krclient::UniversalPatchResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_UniversalPatch_, context, request, response, std::move(f));
}

void KrCoreApi::Stub::async::UniversalPatch(::grpc::ClientContext* context, const ::krclient::UniversalPatchRequest* request, ::krclient::UniversalPatchResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_UniversalPatch_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::krclient::UniversalPatchResponse>* KrCoreApi::Stub::PrepareAsyncUniversalPatchRaw(::grpc::ClientContext* context, const ::krclient::UniversalPatchRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::krclient::UniversalPatchResponse, ::krclient::UniversalPatchRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_UniversalPatch_, context, request);
}

::grpc::ClientAsyncResponseReader< ::krclient::UniversalPatchResponse>* KrCoreApi::Stub::AsyncUniversalPatchRaw(::grpc::ClientContext* context, const ::krclient::UniversalPatchRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncUniversalPatchRaw(context, request, cq);
  result->StartCall();
  return result;
}

KrCoreApi::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      KrCoreApi_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< KrCoreApi::Service, ::krclient::CancelTaskRequest, ::krclient::CancelTaskResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](KrCoreApi::Service* service,
             ::grpc::ServerContext* ctx,
             const ::krclient::CancelTaskRequest* req,
             ::krclient::CancelTaskResponse* resp) {
               return service->CancelTask(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      KrCoreApi_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< KrCoreApi::Service, ::krclient::EmitCommandRequest, ::krclient::EmitCommandResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](KrCoreApi::Service* service,
             ::grpc::ServerContext* ctx,
             const ::krclient::EmitCommandRequest* req,
             ::krclient::EmitCommandResponse* resp) {
               return service->EmitCommand(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      KrCoreApi_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< KrCoreApi::Service, ::krclient::PackerRequest, ::krclient::PackerResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](KrCoreApi::Service* service,
             ::grpc::ServerContext* ctx,
             const ::krclient::PackerRequest* req,
             ::krclient::PackerResponse* resp) {
               return service->Packer(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      KrCoreApi_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< KrCoreApi::Service, ::krclient::TaskCloseWindowRequest, ::krclient::TaskCloseWindowResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](KrCoreApi::Service* service,
             ::grpc::ServerContext* ctx,
             const ::krclient::TaskCloseWindowRequest* req,
             ::krclient::TaskCloseWindowResponse* resp) {
               return service->TaskCloseWindow(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      KrCoreApi_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< KrCoreApi::Service, ::krclient::TaskDumpStartRequest, ::krclient::TaskDumpStartResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](KrCoreApi::Service* service,
             ::grpc::ServerContext* ctx,
             const ::krclient::TaskDumpStartRequest* req,
             ::krclient::TaskDumpStartResponse* resp) {
               return service->TaskDumpStart(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      KrCoreApi_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< KrCoreApi::Service, ::krclient::UniversalDumperRequest, ::krclient::UniversalDumperResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](KrCoreApi::Service* service,
             ::grpc::ServerContext* ctx,
             const ::krclient::UniversalDumperRequest* req,
             ::krclient::UniversalDumperResponse* resp) {
               return service->UniversalDumper(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      KrCoreApi_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< KrCoreApi::Service, ::krclient::UniversalPatchRequest, ::krclient::UniversalPatchResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](KrCoreApi::Service* service,
             ::grpc::ServerContext* ctx,
             const ::krclient::UniversalPatchRequest* req,
             ::krclient::UniversalPatchResponse* resp) {
               return service->UniversalPatch(ctx, req, resp);
             }, this)));
}

KrCoreApi::Service::~Service() {
}

::grpc::Status KrCoreApi::Service::CancelTask(::grpc::ServerContext* context, const ::krclient::CancelTaskRequest* request, ::krclient::CancelTaskResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status KrCoreApi::Service::EmitCommand(::grpc::ServerContext* context, const ::krclient::EmitCommandRequest* request, ::krclient::EmitCommandResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status KrCoreApi::Service::Packer(::grpc::ServerContext* context, const ::krclient::PackerRequest* request, ::krclient::PackerResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status KrCoreApi::Service::TaskCloseWindow(::grpc::ServerContext* context, const ::krclient::TaskCloseWindowRequest* request, ::krclient::TaskCloseWindowResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status KrCoreApi::Service::TaskDumpStart(::grpc::ServerContext* context, const ::krclient::TaskDumpStartRequest* request, ::krclient::TaskDumpStartResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status KrCoreApi::Service::UniversalDumper(::grpc::ServerContext* context, const ::krclient::UniversalDumperRequest* request, ::krclient::UniversalDumperResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status KrCoreApi::Service::UniversalPatch(::grpc::ServerContext* context, const ::krclient::UniversalPatchRequest* request, ::krclient::UniversalPatchResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace krclient

