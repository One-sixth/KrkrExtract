// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: client.proto
#ifndef GRPC_client_2eproto__INCLUDED
#define GRPC_client_2eproto__INCLUDED

#include "client.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace krclient {

class KrCoreApi final {
 public:
  static constexpr char const* service_full_name() {
    return "krclient.KrCoreApi";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status CancelTask(::grpc::ClientContext* context, const ::krclient::CancelTaskRequest& request, ::krclient::CancelTaskResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::CancelTaskResponse>> AsyncCancelTask(::grpc::ClientContext* context, const ::krclient::CancelTaskRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::CancelTaskResponse>>(AsyncCancelTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::CancelTaskResponse>> PrepareAsyncCancelTask(::grpc::ClientContext* context, const ::krclient::CancelTaskRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::CancelTaskResponse>>(PrepareAsyncCancelTaskRaw(context, request, cq));
    }
    virtual ::grpc::Status EmitCommand(::grpc::ClientContext* context, const ::krclient::EmitCommandRequest& request, ::krclient::EmitCommandResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::EmitCommandResponse>> AsyncEmitCommand(::grpc::ClientContext* context, const ::krclient::EmitCommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::EmitCommandResponse>>(AsyncEmitCommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::EmitCommandResponse>> PrepareAsyncEmitCommand(::grpc::ClientContext* context, const ::krclient::EmitCommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::EmitCommandResponse>>(PrepareAsyncEmitCommandRaw(context, request, cq));
    }
    virtual ::grpc::Status Packer(::grpc::ClientContext* context, const ::krclient::PackerRequest& request, ::krclient::PackerResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::PackerResponse>> AsyncPacker(::grpc::ClientContext* context, const ::krclient::PackerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::PackerResponse>>(AsyncPackerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::PackerResponse>> PrepareAsyncPacker(::grpc::ClientContext* context, const ::krclient::PackerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::PackerResponse>>(PrepareAsyncPackerRaw(context, request, cq));
    }
    virtual ::grpc::Status TaskCloseWindow(::grpc::ClientContext* context, const ::krclient::TaskCloseWindowRequest& request, ::krclient::TaskCloseWindowResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::TaskCloseWindowResponse>> AsyncTaskCloseWindow(::grpc::ClientContext* context, const ::krclient::TaskCloseWindowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::TaskCloseWindowResponse>>(AsyncTaskCloseWindowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::TaskCloseWindowResponse>> PrepareAsyncTaskCloseWindow(::grpc::ClientContext* context, const ::krclient::TaskCloseWindowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::TaskCloseWindowResponse>>(PrepareAsyncTaskCloseWindowRaw(context, request, cq));
    }
    virtual ::grpc::Status TaskDumpStart(::grpc::ClientContext* context, const ::krclient::TaskDumpStartRequest& request, ::krclient::TaskDumpStartResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::TaskDumpStartResponse>> AsyncTaskDumpStart(::grpc::ClientContext* context, const ::krclient::TaskDumpStartRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::TaskDumpStartResponse>>(AsyncTaskDumpStartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::TaskDumpStartResponse>> PrepareAsyncTaskDumpStart(::grpc::ClientContext* context, const ::krclient::TaskDumpStartRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::TaskDumpStartResponse>>(PrepareAsyncTaskDumpStartRaw(context, request, cq));
    }
    virtual ::grpc::Status UniversalDumper(::grpc::ClientContext* context, const ::krclient::UniversalDumperRequest& request, ::krclient::UniversalDumperResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::UniversalDumperResponse>> AsyncUniversalDumper(::grpc::ClientContext* context, const ::krclient::UniversalDumperRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::UniversalDumperResponse>>(AsyncUniversalDumperRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::UniversalDumperResponse>> PrepareAsyncUniversalDumper(::grpc::ClientContext* context, const ::krclient::UniversalDumperRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::UniversalDumperResponse>>(PrepareAsyncUniversalDumperRaw(context, request, cq));
    }
    virtual ::grpc::Status UniversalPatch(::grpc::ClientContext* context, const ::krclient::UniversalPatchRequest& request, ::krclient::UniversalPatchResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::UniversalPatchResponse>> AsyncUniversalPatch(::grpc::ClientContext* context, const ::krclient::UniversalPatchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::UniversalPatchResponse>>(AsyncUniversalPatchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::UniversalPatchResponse>> PrepareAsyncUniversalPatch(::grpc::ClientContext* context, const ::krclient::UniversalPatchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::krclient::UniversalPatchResponse>>(PrepareAsyncUniversalPatchRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void CancelTask(::grpc::ClientContext* context, const ::krclient::CancelTaskRequest* request, ::krclient::CancelTaskResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CancelTask(::grpc::ClientContext* context, const ::krclient::CancelTaskRequest* request, ::krclient::CancelTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void EmitCommand(::grpc::ClientContext* context, const ::krclient::EmitCommandRequest* request, ::krclient::EmitCommandResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void EmitCommand(::grpc::ClientContext* context, const ::krclient::EmitCommandRequest* request, ::krclient::EmitCommandResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Packer(::grpc::ClientContext* context, const ::krclient::PackerRequest* request, ::krclient::PackerResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Packer(::grpc::ClientContext* context, const ::krclient::PackerRequest* request, ::krclient::PackerResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void TaskCloseWindow(::grpc::ClientContext* context, const ::krclient::TaskCloseWindowRequest* request, ::krclient::TaskCloseWindowResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TaskCloseWindow(::grpc::ClientContext* context, const ::krclient::TaskCloseWindowRequest* request, ::krclient::TaskCloseWindowResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void TaskDumpStart(::grpc::ClientContext* context, const ::krclient::TaskDumpStartRequest* request, ::krclient::TaskDumpStartResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TaskDumpStart(::grpc::ClientContext* context, const ::krclient::TaskDumpStartRequest* request, ::krclient::TaskDumpStartResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void UniversalDumper(::grpc::ClientContext* context, const ::krclient::UniversalDumperRequest* request, ::krclient::UniversalDumperResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UniversalDumper(::grpc::ClientContext* context, const ::krclient::UniversalDumperRequest* request, ::krclient::UniversalDumperResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void UniversalPatch(::grpc::ClientContext* context, const ::krclient::UniversalPatchRequest* request, ::krclient::UniversalPatchResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UniversalPatch(::grpc::ClientContext* context, const ::krclient::UniversalPatchRequest* request, ::krclient::UniversalPatchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::krclient::CancelTaskResponse>* AsyncCancelTaskRaw(::grpc::ClientContext* context, const ::krclient::CancelTaskRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::krclient::CancelTaskResponse>* PrepareAsyncCancelTaskRaw(::grpc::ClientContext* context, const ::krclient::CancelTaskRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::krclient::EmitCommandResponse>* AsyncEmitCommandRaw(::grpc::ClientContext* context, const ::krclient::EmitCommandRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::krclient::EmitCommandResponse>* PrepareAsyncEmitCommandRaw(::grpc::ClientContext* context, const ::krclient::EmitCommandRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::krclient::PackerResponse>* AsyncPackerRaw(::grpc::ClientContext* context, const ::krclient::PackerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::krclient::PackerResponse>* PrepareAsyncPackerRaw(::grpc::ClientContext* context, const ::krclient::PackerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::krclient::TaskCloseWindowResponse>* AsyncTaskCloseWindowRaw(::grpc::ClientContext* context, const ::krclient::TaskCloseWindowRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::krclient::TaskCloseWindowResponse>* PrepareAsyncTaskCloseWindowRaw(::grpc::ClientContext* context, const ::krclient::TaskCloseWindowRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::krclient::TaskDumpStartResponse>* AsyncTaskDumpStartRaw(::grpc::ClientContext* context, const ::krclient::TaskDumpStartRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::krclient::TaskDumpStartResponse>* PrepareAsyncTaskDumpStartRaw(::grpc::ClientContext* context, const ::krclient::TaskDumpStartRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::krclient::UniversalDumperResponse>* AsyncUniversalDumperRaw(::grpc::ClientContext* context, const ::krclient::UniversalDumperRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::krclient::UniversalDumperResponse>* PrepareAsyncUniversalDumperRaw(::grpc::ClientContext* context, const ::krclient::UniversalDumperRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::krclient::UniversalPatchResponse>* AsyncUniversalPatchRaw(::grpc::ClientContext* context, const ::krclient::UniversalPatchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::krclient::UniversalPatchResponse>* PrepareAsyncUniversalPatchRaw(::grpc::ClientContext* context, const ::krclient::UniversalPatchRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status CancelTask(::grpc::ClientContext* context, const ::krclient::CancelTaskRequest& request, ::krclient::CancelTaskResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::CancelTaskResponse>> AsyncCancelTask(::grpc::ClientContext* context, const ::krclient::CancelTaskRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::CancelTaskResponse>>(AsyncCancelTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::CancelTaskResponse>> PrepareAsyncCancelTask(::grpc::ClientContext* context, const ::krclient::CancelTaskRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::CancelTaskResponse>>(PrepareAsyncCancelTaskRaw(context, request, cq));
    }
    ::grpc::Status EmitCommand(::grpc::ClientContext* context, const ::krclient::EmitCommandRequest& request, ::krclient::EmitCommandResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::EmitCommandResponse>> AsyncEmitCommand(::grpc::ClientContext* context, const ::krclient::EmitCommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::EmitCommandResponse>>(AsyncEmitCommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::EmitCommandResponse>> PrepareAsyncEmitCommand(::grpc::ClientContext* context, const ::krclient::EmitCommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::EmitCommandResponse>>(PrepareAsyncEmitCommandRaw(context, request, cq));
    }
    ::grpc::Status Packer(::grpc::ClientContext* context, const ::krclient::PackerRequest& request, ::krclient::PackerResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::PackerResponse>> AsyncPacker(::grpc::ClientContext* context, const ::krclient::PackerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::PackerResponse>>(AsyncPackerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::PackerResponse>> PrepareAsyncPacker(::grpc::ClientContext* context, const ::krclient::PackerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::PackerResponse>>(PrepareAsyncPackerRaw(context, request, cq));
    }
    ::grpc::Status TaskCloseWindow(::grpc::ClientContext* context, const ::krclient::TaskCloseWindowRequest& request, ::krclient::TaskCloseWindowResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::TaskCloseWindowResponse>> AsyncTaskCloseWindow(::grpc::ClientContext* context, const ::krclient::TaskCloseWindowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::TaskCloseWindowResponse>>(AsyncTaskCloseWindowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::TaskCloseWindowResponse>> PrepareAsyncTaskCloseWindow(::grpc::ClientContext* context, const ::krclient::TaskCloseWindowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::TaskCloseWindowResponse>>(PrepareAsyncTaskCloseWindowRaw(context, request, cq));
    }
    ::grpc::Status TaskDumpStart(::grpc::ClientContext* context, const ::krclient::TaskDumpStartRequest& request, ::krclient::TaskDumpStartResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::TaskDumpStartResponse>> AsyncTaskDumpStart(::grpc::ClientContext* context, const ::krclient::TaskDumpStartRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::TaskDumpStartResponse>>(AsyncTaskDumpStartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::TaskDumpStartResponse>> PrepareAsyncTaskDumpStart(::grpc::ClientContext* context, const ::krclient::TaskDumpStartRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::TaskDumpStartResponse>>(PrepareAsyncTaskDumpStartRaw(context, request, cq));
    }
    ::grpc::Status UniversalDumper(::grpc::ClientContext* context, const ::krclient::UniversalDumperRequest& request, ::krclient::UniversalDumperResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::UniversalDumperResponse>> AsyncUniversalDumper(::grpc::ClientContext* context, const ::krclient::UniversalDumperRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::UniversalDumperResponse>>(AsyncUniversalDumperRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::UniversalDumperResponse>> PrepareAsyncUniversalDumper(::grpc::ClientContext* context, const ::krclient::UniversalDumperRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::UniversalDumperResponse>>(PrepareAsyncUniversalDumperRaw(context, request, cq));
    }
    ::grpc::Status UniversalPatch(::grpc::ClientContext* context, const ::krclient::UniversalPatchRequest& request, ::krclient::UniversalPatchResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::UniversalPatchResponse>> AsyncUniversalPatch(::grpc::ClientContext* context, const ::krclient::UniversalPatchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::UniversalPatchResponse>>(AsyncUniversalPatchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::UniversalPatchResponse>> PrepareAsyncUniversalPatch(::grpc::ClientContext* context, const ::krclient::UniversalPatchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::krclient::UniversalPatchResponse>>(PrepareAsyncUniversalPatchRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void CancelTask(::grpc::ClientContext* context, const ::krclient::CancelTaskRequest* request, ::krclient::CancelTaskResponse* response, std::function<void(::grpc::Status)>) override;
      void CancelTask(::grpc::ClientContext* context, const ::krclient::CancelTaskRequest* request, ::krclient::CancelTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void EmitCommand(::grpc::ClientContext* context, const ::krclient::EmitCommandRequest* request, ::krclient::EmitCommandResponse* response, std::function<void(::grpc::Status)>) override;
      void EmitCommand(::grpc::ClientContext* context, const ::krclient::EmitCommandRequest* request, ::krclient::EmitCommandResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Packer(::grpc::ClientContext* context, const ::krclient::PackerRequest* request, ::krclient::PackerResponse* response, std::function<void(::grpc::Status)>) override;
      void Packer(::grpc::ClientContext* context, const ::krclient::PackerRequest* request, ::krclient::PackerResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void TaskCloseWindow(::grpc::ClientContext* context, const ::krclient::TaskCloseWindowRequest* request, ::krclient::TaskCloseWindowResponse* response, std::function<void(::grpc::Status)>) override;
      void TaskCloseWindow(::grpc::ClientContext* context, const ::krclient::TaskCloseWindowRequest* request, ::krclient::TaskCloseWindowResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void TaskDumpStart(::grpc::ClientContext* context, const ::krclient::TaskDumpStartRequest* request, ::krclient::TaskDumpStartResponse* response, std::function<void(::grpc::Status)>) override;
      void TaskDumpStart(::grpc::ClientContext* context, const ::krclient::TaskDumpStartRequest* request, ::krclient::TaskDumpStartResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UniversalDumper(::grpc::ClientContext* context, const ::krclient::UniversalDumperRequest* request, ::krclient::UniversalDumperResponse* response, std::function<void(::grpc::Status)>) override;
      void UniversalDumper(::grpc::ClientContext* context, const ::krclient::UniversalDumperRequest* request, ::krclient::UniversalDumperResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UniversalPatch(::grpc::ClientContext* context, const ::krclient::UniversalPatchRequest* request, ::krclient::UniversalPatchResponse* response, std::function<void(::grpc::Status)>) override;
      void UniversalPatch(::grpc::ClientContext* context, const ::krclient::UniversalPatchRequest* request, ::krclient::UniversalPatchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::krclient::CancelTaskResponse>* AsyncCancelTaskRaw(::grpc::ClientContext* context, const ::krclient::CancelTaskRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::krclient::CancelTaskResponse>* PrepareAsyncCancelTaskRaw(::grpc::ClientContext* context, const ::krclient::CancelTaskRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::krclient::EmitCommandResponse>* AsyncEmitCommandRaw(::grpc::ClientContext* context, const ::krclient::EmitCommandRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::krclient::EmitCommandResponse>* PrepareAsyncEmitCommandRaw(::grpc::ClientContext* context, const ::krclient::EmitCommandRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::krclient::PackerResponse>* AsyncPackerRaw(::grpc::ClientContext* context, const ::krclient::PackerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::krclient::PackerResponse>* PrepareAsyncPackerRaw(::grpc::ClientContext* context, const ::krclient::PackerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::krclient::TaskCloseWindowResponse>* AsyncTaskCloseWindowRaw(::grpc::ClientContext* context, const ::krclient::TaskCloseWindowRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::krclient::TaskCloseWindowResponse>* PrepareAsyncTaskCloseWindowRaw(::grpc::ClientContext* context, const ::krclient::TaskCloseWindowRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::krclient::TaskDumpStartResponse>* AsyncTaskDumpStartRaw(::grpc::ClientContext* context, const ::krclient::TaskDumpStartRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::krclient::TaskDumpStartResponse>* PrepareAsyncTaskDumpStartRaw(::grpc::ClientContext* context, const ::krclient::TaskDumpStartRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::krclient::UniversalDumperResponse>* AsyncUniversalDumperRaw(::grpc::ClientContext* context, const ::krclient::UniversalDumperRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::krclient::UniversalDumperResponse>* PrepareAsyncUniversalDumperRaw(::grpc::ClientContext* context, const ::krclient::UniversalDumperRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::krclient::UniversalPatchResponse>* AsyncUniversalPatchRaw(::grpc::ClientContext* context, const ::krclient::UniversalPatchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::krclient::UniversalPatchResponse>* PrepareAsyncUniversalPatchRaw(::grpc::ClientContext* context, const ::krclient::UniversalPatchRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_CancelTask_;
    const ::grpc::internal::RpcMethod rpcmethod_EmitCommand_;
    const ::grpc::internal::RpcMethod rpcmethod_Packer_;
    const ::grpc::internal::RpcMethod rpcmethod_TaskCloseWindow_;
    const ::grpc::internal::RpcMethod rpcmethod_TaskDumpStart_;
    const ::grpc::internal::RpcMethod rpcmethod_UniversalDumper_;
    const ::grpc::internal::RpcMethod rpcmethod_UniversalPatch_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status CancelTask(::grpc::ServerContext* context, const ::krclient::CancelTaskRequest* request, ::krclient::CancelTaskResponse* response);
    virtual ::grpc::Status EmitCommand(::grpc::ServerContext* context, const ::krclient::EmitCommandRequest* request, ::krclient::EmitCommandResponse* response);
    virtual ::grpc::Status Packer(::grpc::ServerContext* context, const ::krclient::PackerRequest* request, ::krclient::PackerResponse* response);
    virtual ::grpc::Status TaskCloseWindow(::grpc::ServerContext* context, const ::krclient::TaskCloseWindowRequest* request, ::krclient::TaskCloseWindowResponse* response);
    virtual ::grpc::Status TaskDumpStart(::grpc::ServerContext* context, const ::krclient::TaskDumpStartRequest* request, ::krclient::TaskDumpStartResponse* response);
    virtual ::grpc::Status UniversalDumper(::grpc::ServerContext* context, const ::krclient::UniversalDumperRequest* request, ::krclient::UniversalDumperResponse* response);
    virtual ::grpc::Status UniversalPatch(::grpc::ServerContext* context, const ::krclient::UniversalPatchRequest* request, ::krclient::UniversalPatchResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_CancelTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CancelTask() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_CancelTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelTask(::grpc::ServerContext* /*context*/, const ::krclient::CancelTaskRequest* /*request*/, ::krclient::CancelTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelTask(::grpc::ServerContext* context, ::krclient::CancelTaskRequest* request, ::grpc::ServerAsyncResponseWriter< ::krclient::CancelTaskResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EmitCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EmitCommand() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_EmitCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EmitCommand(::grpc::ServerContext* /*context*/, const ::krclient::EmitCommandRequest* /*request*/, ::krclient::EmitCommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEmitCommand(::grpc::ServerContext* context, ::krclient::EmitCommandRequest* request, ::grpc::ServerAsyncResponseWriter< ::krclient::EmitCommandResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Packer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Packer() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Packer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Packer(::grpc::ServerContext* /*context*/, const ::krclient::PackerRequest* /*request*/, ::krclient::PackerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPacker(::grpc::ServerContext* context, ::krclient::PackerRequest* request, ::grpc::ServerAsyncResponseWriter< ::krclient::PackerResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TaskCloseWindow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TaskCloseWindow() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_TaskCloseWindow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskCloseWindow(::grpc::ServerContext* /*context*/, const ::krclient::TaskCloseWindowRequest* /*request*/, ::krclient::TaskCloseWindowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTaskCloseWindow(::grpc::ServerContext* context, ::krclient::TaskCloseWindowRequest* request, ::grpc::ServerAsyncResponseWriter< ::krclient::TaskCloseWindowResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TaskDumpStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TaskDumpStart() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_TaskDumpStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskDumpStart(::grpc::ServerContext* /*context*/, const ::krclient::TaskDumpStartRequest* /*request*/, ::krclient::TaskDumpStartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTaskDumpStart(::grpc::ServerContext* context, ::krclient::TaskDumpStartRequest* request, ::grpc::ServerAsyncResponseWriter< ::krclient::TaskDumpStartResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UniversalDumper : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UniversalDumper() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_UniversalDumper() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UniversalDumper(::grpc::ServerContext* /*context*/, const ::krclient::UniversalDumperRequest* /*request*/, ::krclient::UniversalDumperResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUniversalDumper(::grpc::ServerContext* context, ::krclient::UniversalDumperRequest* request, ::grpc::ServerAsyncResponseWriter< ::krclient::UniversalDumperResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UniversalPatch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UniversalPatch() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_UniversalPatch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UniversalPatch(::grpc::ServerContext* /*context*/, const ::krclient::UniversalPatchRequest* /*request*/, ::krclient::UniversalPatchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUniversalPatch(::grpc::ServerContext* context, ::krclient::UniversalPatchRequest* request, ::grpc::ServerAsyncResponseWriter< ::krclient::UniversalPatchResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_CancelTask<WithAsyncMethod_EmitCommand<WithAsyncMethod_Packer<WithAsyncMethod_TaskCloseWindow<WithAsyncMethod_TaskDumpStart<WithAsyncMethod_UniversalDumper<WithAsyncMethod_UniversalPatch<Service > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_CancelTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CancelTask() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::krclient::CancelTaskRequest, ::krclient::CancelTaskResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::krclient::CancelTaskRequest* request, ::krclient::CancelTaskResponse* response) { return this->CancelTask(context, request, response); }));}
    void SetMessageAllocatorFor_CancelTask(
        ::grpc::MessageAllocator< ::krclient::CancelTaskRequest, ::krclient::CancelTaskResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::krclient::CancelTaskRequest, ::krclient::CancelTaskResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CancelTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelTask(::grpc::ServerContext* /*context*/, const ::krclient::CancelTaskRequest* /*request*/, ::krclient::CancelTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CancelTask(
      ::grpc::CallbackServerContext* /*context*/, const ::krclient::CancelTaskRequest* /*request*/, ::krclient::CancelTaskResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_EmitCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_EmitCommand() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::krclient::EmitCommandRequest, ::krclient::EmitCommandResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::krclient::EmitCommandRequest* request, ::krclient::EmitCommandResponse* response) { return this->EmitCommand(context, request, response); }));}
    void SetMessageAllocatorFor_EmitCommand(
        ::grpc::MessageAllocator< ::krclient::EmitCommandRequest, ::krclient::EmitCommandResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::krclient::EmitCommandRequest, ::krclient::EmitCommandResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_EmitCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EmitCommand(::grpc::ServerContext* /*context*/, const ::krclient::EmitCommandRequest* /*request*/, ::krclient::EmitCommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* EmitCommand(
      ::grpc::CallbackServerContext* /*context*/, const ::krclient::EmitCommandRequest* /*request*/, ::krclient::EmitCommandResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Packer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Packer() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::krclient::PackerRequest, ::krclient::PackerResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::krclient::PackerRequest* request, ::krclient::PackerResponse* response) { return this->Packer(context, request, response); }));}
    void SetMessageAllocatorFor_Packer(
        ::grpc::MessageAllocator< ::krclient::PackerRequest, ::krclient::PackerResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::krclient::PackerRequest, ::krclient::PackerResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Packer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Packer(::grpc::ServerContext* /*context*/, const ::krclient::PackerRequest* /*request*/, ::krclient::PackerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Packer(
      ::grpc::CallbackServerContext* /*context*/, const ::krclient::PackerRequest* /*request*/, ::krclient::PackerResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_TaskCloseWindow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_TaskCloseWindow() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::krclient::TaskCloseWindowRequest, ::krclient::TaskCloseWindowResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::krclient::TaskCloseWindowRequest* request, ::krclient::TaskCloseWindowResponse* response) { return this->TaskCloseWindow(context, request, response); }));}
    void SetMessageAllocatorFor_TaskCloseWindow(
        ::grpc::MessageAllocator< ::krclient::TaskCloseWindowRequest, ::krclient::TaskCloseWindowResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::krclient::TaskCloseWindowRequest, ::krclient::TaskCloseWindowResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_TaskCloseWindow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskCloseWindow(::grpc::ServerContext* /*context*/, const ::krclient::TaskCloseWindowRequest* /*request*/, ::krclient::TaskCloseWindowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TaskCloseWindow(
      ::grpc::CallbackServerContext* /*context*/, const ::krclient::TaskCloseWindowRequest* /*request*/, ::krclient::TaskCloseWindowResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_TaskDumpStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_TaskDumpStart() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::krclient::TaskDumpStartRequest, ::krclient::TaskDumpStartResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::krclient::TaskDumpStartRequest* request, ::krclient::TaskDumpStartResponse* response) { return this->TaskDumpStart(context, request, response); }));}
    void SetMessageAllocatorFor_TaskDumpStart(
        ::grpc::MessageAllocator< ::krclient::TaskDumpStartRequest, ::krclient::TaskDumpStartResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::krclient::TaskDumpStartRequest, ::krclient::TaskDumpStartResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_TaskDumpStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskDumpStart(::grpc::ServerContext* /*context*/, const ::krclient::TaskDumpStartRequest* /*request*/, ::krclient::TaskDumpStartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TaskDumpStart(
      ::grpc::CallbackServerContext* /*context*/, const ::krclient::TaskDumpStartRequest* /*request*/, ::krclient::TaskDumpStartResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UniversalDumper : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UniversalDumper() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::krclient::UniversalDumperRequest, ::krclient::UniversalDumperResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::krclient::UniversalDumperRequest* request, ::krclient::UniversalDumperResponse* response) { return this->UniversalDumper(context, request, response); }));}
    void SetMessageAllocatorFor_UniversalDumper(
        ::grpc::MessageAllocator< ::krclient::UniversalDumperRequest, ::krclient::UniversalDumperResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::krclient::UniversalDumperRequest, ::krclient::UniversalDumperResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UniversalDumper() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UniversalDumper(::grpc::ServerContext* /*context*/, const ::krclient::UniversalDumperRequest* /*request*/, ::krclient::UniversalDumperResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UniversalDumper(
      ::grpc::CallbackServerContext* /*context*/, const ::krclient::UniversalDumperRequest* /*request*/, ::krclient::UniversalDumperResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UniversalPatch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UniversalPatch() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::krclient::UniversalPatchRequest, ::krclient::UniversalPatchResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::krclient::UniversalPatchRequest* request, ::krclient::UniversalPatchResponse* response) { return this->UniversalPatch(context, request, response); }));}
    void SetMessageAllocatorFor_UniversalPatch(
        ::grpc::MessageAllocator< ::krclient::UniversalPatchRequest, ::krclient::UniversalPatchResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::krclient::UniversalPatchRequest, ::krclient::UniversalPatchResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UniversalPatch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UniversalPatch(::grpc::ServerContext* /*context*/, const ::krclient::UniversalPatchRequest* /*request*/, ::krclient::UniversalPatchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UniversalPatch(
      ::grpc::CallbackServerContext* /*context*/, const ::krclient::UniversalPatchRequest* /*request*/, ::krclient::UniversalPatchResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_CancelTask<WithCallbackMethod_EmitCommand<WithCallbackMethod_Packer<WithCallbackMethod_TaskCloseWindow<WithCallbackMethod_TaskDumpStart<WithCallbackMethod_UniversalDumper<WithCallbackMethod_UniversalPatch<Service > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_CancelTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CancelTask() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_CancelTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelTask(::grpc::ServerContext* /*context*/, const ::krclient::CancelTaskRequest* /*request*/, ::krclient::CancelTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EmitCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EmitCommand() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_EmitCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EmitCommand(::grpc::ServerContext* /*context*/, const ::krclient::EmitCommandRequest* /*request*/, ::krclient::EmitCommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Packer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Packer() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Packer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Packer(::grpc::ServerContext* /*context*/, const ::krclient::PackerRequest* /*request*/, ::krclient::PackerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TaskCloseWindow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TaskCloseWindow() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_TaskCloseWindow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskCloseWindow(::grpc::ServerContext* /*context*/, const ::krclient::TaskCloseWindowRequest* /*request*/, ::krclient::TaskCloseWindowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TaskDumpStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TaskDumpStart() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_TaskDumpStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskDumpStart(::grpc::ServerContext* /*context*/, const ::krclient::TaskDumpStartRequest* /*request*/, ::krclient::TaskDumpStartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UniversalDumper : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UniversalDumper() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_UniversalDumper() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UniversalDumper(::grpc::ServerContext* /*context*/, const ::krclient::UniversalDumperRequest* /*request*/, ::krclient::UniversalDumperResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UniversalPatch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UniversalPatch() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_UniversalPatch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UniversalPatch(::grpc::ServerContext* /*context*/, const ::krclient::UniversalPatchRequest* /*request*/, ::krclient::UniversalPatchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_CancelTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CancelTask() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_CancelTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelTask(::grpc::ServerContext* /*context*/, const ::krclient::CancelTaskRequest* /*request*/, ::krclient::CancelTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelTask(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EmitCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EmitCommand() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_EmitCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EmitCommand(::grpc::ServerContext* /*context*/, const ::krclient::EmitCommandRequest* /*request*/, ::krclient::EmitCommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEmitCommand(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Packer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Packer() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Packer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Packer(::grpc::ServerContext* /*context*/, const ::krclient::PackerRequest* /*request*/, ::krclient::PackerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPacker(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TaskCloseWindow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TaskCloseWindow() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_TaskCloseWindow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskCloseWindow(::grpc::ServerContext* /*context*/, const ::krclient::TaskCloseWindowRequest* /*request*/, ::krclient::TaskCloseWindowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTaskCloseWindow(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TaskDumpStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TaskDumpStart() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_TaskDumpStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskDumpStart(::grpc::ServerContext* /*context*/, const ::krclient::TaskDumpStartRequest* /*request*/, ::krclient::TaskDumpStartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTaskDumpStart(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UniversalDumper : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UniversalDumper() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_UniversalDumper() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UniversalDumper(::grpc::ServerContext* /*context*/, const ::krclient::UniversalDumperRequest* /*request*/, ::krclient::UniversalDumperResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUniversalDumper(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UniversalPatch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UniversalPatch() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_UniversalPatch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UniversalPatch(::grpc::ServerContext* /*context*/, const ::krclient::UniversalPatchRequest* /*request*/, ::krclient::UniversalPatchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUniversalPatch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CancelTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CancelTask() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CancelTask(context, request, response); }));
    }
    ~WithRawCallbackMethod_CancelTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelTask(::grpc::ServerContext* /*context*/, const ::krclient::CancelTaskRequest* /*request*/, ::krclient::CancelTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CancelTask(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_EmitCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_EmitCommand() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EmitCommand(context, request, response); }));
    }
    ~WithRawCallbackMethod_EmitCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EmitCommand(::grpc::ServerContext* /*context*/, const ::krclient::EmitCommandRequest* /*request*/, ::krclient::EmitCommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* EmitCommand(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Packer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Packer() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Packer(context, request, response); }));
    }
    ~WithRawCallbackMethod_Packer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Packer(::grpc::ServerContext* /*context*/, const ::krclient::PackerRequest* /*request*/, ::krclient::PackerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Packer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_TaskCloseWindow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_TaskCloseWindow() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TaskCloseWindow(context, request, response); }));
    }
    ~WithRawCallbackMethod_TaskCloseWindow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskCloseWindow(::grpc::ServerContext* /*context*/, const ::krclient::TaskCloseWindowRequest* /*request*/, ::krclient::TaskCloseWindowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TaskCloseWindow(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_TaskDumpStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_TaskDumpStart() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TaskDumpStart(context, request, response); }));
    }
    ~WithRawCallbackMethod_TaskDumpStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskDumpStart(::grpc::ServerContext* /*context*/, const ::krclient::TaskDumpStartRequest* /*request*/, ::krclient::TaskDumpStartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TaskDumpStart(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UniversalDumper : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UniversalDumper() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UniversalDumper(context, request, response); }));
    }
    ~WithRawCallbackMethod_UniversalDumper() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UniversalDumper(::grpc::ServerContext* /*context*/, const ::krclient::UniversalDumperRequest* /*request*/, ::krclient::UniversalDumperResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UniversalDumper(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UniversalPatch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UniversalPatch() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UniversalPatch(context, request, response); }));
    }
    ~WithRawCallbackMethod_UniversalPatch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UniversalPatch(::grpc::ServerContext* /*context*/, const ::krclient::UniversalPatchRequest* /*request*/, ::krclient::UniversalPatchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UniversalPatch(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CancelTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CancelTask() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::krclient::CancelTaskRequest, ::krclient::CancelTaskResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::krclient::CancelTaskRequest, ::krclient::CancelTaskResponse>* streamer) {
                       return this->StreamedCancelTask(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CancelTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CancelTask(::grpc::ServerContext* /*context*/, const ::krclient::CancelTaskRequest* /*request*/, ::krclient::CancelTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCancelTask(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::krclient::CancelTaskRequest,::krclient::CancelTaskResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EmitCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EmitCommand() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::krclient::EmitCommandRequest, ::krclient::EmitCommandResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::krclient::EmitCommandRequest, ::krclient::EmitCommandResponse>* streamer) {
                       return this->StreamedEmitCommand(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EmitCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EmitCommand(::grpc::ServerContext* /*context*/, const ::krclient::EmitCommandRequest* /*request*/, ::krclient::EmitCommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEmitCommand(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::krclient::EmitCommandRequest,::krclient::EmitCommandResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Packer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Packer() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::krclient::PackerRequest, ::krclient::PackerResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::krclient::PackerRequest, ::krclient::PackerResponse>* streamer) {
                       return this->StreamedPacker(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Packer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Packer(::grpc::ServerContext* /*context*/, const ::krclient::PackerRequest* /*request*/, ::krclient::PackerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPacker(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::krclient::PackerRequest,::krclient::PackerResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TaskCloseWindow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TaskCloseWindow() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::krclient::TaskCloseWindowRequest, ::krclient::TaskCloseWindowResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::krclient::TaskCloseWindowRequest, ::krclient::TaskCloseWindowResponse>* streamer) {
                       return this->StreamedTaskCloseWindow(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TaskCloseWindow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TaskCloseWindow(::grpc::ServerContext* /*context*/, const ::krclient::TaskCloseWindowRequest* /*request*/, ::krclient::TaskCloseWindowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTaskCloseWindow(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::krclient::TaskCloseWindowRequest,::krclient::TaskCloseWindowResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TaskDumpStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TaskDumpStart() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::krclient::TaskDumpStartRequest, ::krclient::TaskDumpStartResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::krclient::TaskDumpStartRequest, ::krclient::TaskDumpStartResponse>* streamer) {
                       return this->StreamedTaskDumpStart(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TaskDumpStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TaskDumpStart(::grpc::ServerContext* /*context*/, const ::krclient::TaskDumpStartRequest* /*request*/, ::krclient::TaskDumpStartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTaskDumpStart(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::krclient::TaskDumpStartRequest,::krclient::TaskDumpStartResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UniversalDumper : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UniversalDumper() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::krclient::UniversalDumperRequest, ::krclient::UniversalDumperResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::krclient::UniversalDumperRequest, ::krclient::UniversalDumperResponse>* streamer) {
                       return this->StreamedUniversalDumper(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UniversalDumper() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UniversalDumper(::grpc::ServerContext* /*context*/, const ::krclient::UniversalDumperRequest* /*request*/, ::krclient::UniversalDumperResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUniversalDumper(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::krclient::UniversalDumperRequest,::krclient::UniversalDumperResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UniversalPatch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UniversalPatch() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::krclient::UniversalPatchRequest, ::krclient::UniversalPatchResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::krclient::UniversalPatchRequest, ::krclient::UniversalPatchResponse>* streamer) {
                       return this->StreamedUniversalPatch(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UniversalPatch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UniversalPatch(::grpc::ServerContext* /*context*/, const ::krclient::UniversalPatchRequest* /*request*/, ::krclient::UniversalPatchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUniversalPatch(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::krclient::UniversalPatchRequest,::krclient::UniversalPatchResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CancelTask<WithStreamedUnaryMethod_EmitCommand<WithStreamedUnaryMethod_Packer<WithStreamedUnaryMethod_TaskCloseWindow<WithStreamedUnaryMethod_TaskDumpStart<WithStreamedUnaryMethod_UniversalDumper<WithStreamedUnaryMethod_UniversalPatch<Service > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_CancelTask<WithStreamedUnaryMethod_EmitCommand<WithStreamedUnaryMethod_Packer<WithStreamedUnaryMethod_TaskCloseWindow<WithStreamedUnaryMethod_TaskDumpStart<WithStreamedUnaryMethod_UniversalDumper<WithStreamedUnaryMethod_UniversalPatch<Service > > > > > > > StreamedService;
};

}  // namespace krclient


#endif  // GRPC_client_2eproto__INCLUDED
