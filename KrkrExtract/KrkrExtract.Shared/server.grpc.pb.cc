// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: server.proto

#include "server.pb.h"
#include "server.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace krserver {

static const char* KrConnectionApi_method_names[] = {
  "/krserver.KrConnectionApi/ServerProgressBar",
  "/krserver.KrConnectionApi/ServerCommandResultOutput",
  "/krserver.KrConnectionApi/ServerExitFromRemoteProcess",
  "/krserver.KrConnectionApi/ServerLogOutput",
  "/krserver.KrConnectionApi/ServerMessageBox",
  "/krserver.KrConnectionApi/ServerTaskEndAndEnableUI",
  "/krserver.KrConnectionApi/ServerTaskStartAndDisableUI",
  "/krserver.KrConnectionApi/ServerUIHeartbeatPackage",
  "/krserver.KrConnectionApi/ServerUIReady",
};

std::unique_ptr< KrConnectionApi::Stub> KrConnectionApi::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< KrConnectionApi::Stub> stub(new KrConnectionApi::Stub(channel, options));
  return stub;
}

KrConnectionApi::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_ServerProgressBar_(KrConnectionApi_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ServerCommandResultOutput_(KrConnectionApi_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ServerExitFromRemoteProcess_(KrConnectionApi_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ServerLogOutput_(KrConnectionApi_method_names[3], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ServerMessageBox_(KrConnectionApi_method_names[4], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ServerTaskEndAndEnableUI_(KrConnectionApi_method_names[5], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ServerTaskStartAndDisableUI_(KrConnectionApi_method_names[6], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ServerUIHeartbeatPackage_(KrConnectionApi_method_names[7], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ServerUIReady_(KrConnectionApi_method_names[8], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status KrConnectionApi::Stub::ServerProgressBar(::grpc::ClientContext* context, const ::krserver::ServerProgressBarRequest& request, ::krserver::ServerProgressBarResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::krserver::ServerProgressBarRequest, ::krserver::ServerProgressBarResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ServerProgressBar_, context, request, response);
}

void KrConnectionApi::Stub::async::ServerProgressBar(::grpc::ClientContext* context, const ::krserver::ServerProgressBarRequest* request, ::krserver::ServerProgressBarResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::krserver::ServerProgressBarRequest, ::krserver::ServerProgressBarResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ServerProgressBar_, context, request, response, std::move(f));
}

void KrConnectionApi::Stub::async::ServerProgressBar(::grpc::ClientContext* context, const ::krserver::ServerProgressBarRequest* request, ::krserver::ServerProgressBarResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ServerProgressBar_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::krserver::ServerProgressBarResponse>* KrConnectionApi::Stub::PrepareAsyncServerProgressBarRaw(::grpc::ClientContext* context, const ::krserver::ServerProgressBarRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::krserver::ServerProgressBarResponse, ::krserver::ServerProgressBarRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ServerProgressBar_, context, request);
}

::grpc::ClientAsyncResponseReader< ::krserver::ServerProgressBarResponse>* KrConnectionApi::Stub::AsyncServerProgressBarRaw(::grpc::ClientContext* context, const ::krserver::ServerProgressBarRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncServerProgressBarRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status KrConnectionApi::Stub::ServerCommandResultOutput(::grpc::ClientContext* context, const ::krserver::ServerCommandResultOutputRequest& request, ::krserver::ServerCommandResultOutputResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::krserver::ServerCommandResultOutputRequest, ::krserver::ServerCommandResultOutputResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ServerCommandResultOutput_, context, request, response);
}

void KrConnectionApi::Stub::async::ServerCommandResultOutput(::grpc::ClientContext* context, const ::krserver::ServerCommandResultOutputRequest* request, ::krserver::ServerCommandResultOutputResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::krserver::ServerCommandResultOutputRequest, ::krserver::ServerCommandResultOutputResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ServerCommandResultOutput_, context, request, response, std::move(f));
}

void KrConnectionApi::Stub::async::ServerCommandResultOutput(::grpc::ClientContext* context, const ::krserver::ServerCommandResultOutputRequest* request, ::krserver::ServerCommandResultOutputResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ServerCommandResultOutput_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::krserver::ServerCommandResultOutputResponse>* KrConnectionApi::Stub::PrepareAsyncServerCommandResultOutputRaw(::grpc::ClientContext* context, const ::krserver::ServerCommandResultOutputRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::krserver::ServerCommandResultOutputResponse, ::krserver::ServerCommandResultOutputRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ServerCommandResultOutput_, context, request);
}

::grpc::ClientAsyncResponseReader< ::krserver::ServerCommandResultOutputResponse>* KrConnectionApi::Stub::AsyncServerCommandResultOutputRaw(::grpc::ClientContext* context, const ::krserver::ServerCommandResultOutputRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncServerCommandResultOutputRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status KrConnectionApi::Stub::ServerExitFromRemoteProcess(::grpc::ClientContext* context, const ::krserver::ServerExitFromRemoteProcessRequest& request, ::krserver::ServerExitFromRemoteProcessResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::krserver::ServerExitFromRemoteProcessRequest, ::krserver::ServerExitFromRemoteProcessResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ServerExitFromRemoteProcess_, context, request, response);
}

void KrConnectionApi::Stub::async::ServerExitFromRemoteProcess(::grpc::ClientContext* context, const ::krserver::ServerExitFromRemoteProcessRequest* request, ::krserver::ServerExitFromRemoteProcessResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::krserver::ServerExitFromRemoteProcessRequest, ::krserver::ServerExitFromRemoteProcessResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ServerExitFromRemoteProcess_, context, request, response, std::move(f));
}

void KrConnectionApi::Stub::async::ServerExitFromRemoteProcess(::grpc::ClientContext* context, const ::krserver::ServerExitFromRemoteProcessRequest* request, ::krserver::ServerExitFromRemoteProcessResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ServerExitFromRemoteProcess_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::krserver::ServerExitFromRemoteProcessResponse>* KrConnectionApi::Stub::PrepareAsyncServerExitFromRemoteProcessRaw(::grpc::ClientContext* context, const ::krserver::ServerExitFromRemoteProcessRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::krserver::ServerExitFromRemoteProcessResponse, ::krserver::ServerExitFromRemoteProcessRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ServerExitFromRemoteProcess_, context, request);
}

::grpc::ClientAsyncResponseReader< ::krserver::ServerExitFromRemoteProcessResponse>* KrConnectionApi::Stub::AsyncServerExitFromRemoteProcessRaw(::grpc::ClientContext* context, const ::krserver::ServerExitFromRemoteProcessRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncServerExitFromRemoteProcessRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status KrConnectionApi::Stub::ServerLogOutput(::grpc::ClientContext* context, const ::krserver::ServerLogOutputRequest& request, ::krserver::ServerLogOutputResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::krserver::ServerLogOutputRequest, ::krserver::ServerLogOutputResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ServerLogOutput_, context, request, response);
}

void KrConnectionApi::Stub::async::ServerLogOutput(::grpc::ClientContext* context, const ::krserver::ServerLogOutputRequest* request, ::krserver::ServerLogOutputResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::krserver::ServerLogOutputRequest, ::krserver::ServerLogOutputResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ServerLogOutput_, context, request, response, std::move(f));
}

void KrConnectionApi::Stub::async::ServerLogOutput(::grpc::ClientContext* context, const ::krserver::ServerLogOutputRequest* request, ::krserver::ServerLogOutputResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ServerLogOutput_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::krserver::ServerLogOutputResponse>* KrConnectionApi::Stub::PrepareAsyncServerLogOutputRaw(::grpc::ClientContext* context, const ::krserver::ServerLogOutputRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::krserver::ServerLogOutputResponse, ::krserver::ServerLogOutputRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ServerLogOutput_, context, request);
}

::grpc::ClientAsyncResponseReader< ::krserver::ServerLogOutputResponse>* KrConnectionApi::Stub::AsyncServerLogOutputRaw(::grpc::ClientContext* context, const ::krserver::ServerLogOutputRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncServerLogOutputRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status KrConnectionApi::Stub::ServerMessageBox(::grpc::ClientContext* context, const ::krserver::ServerMessageBoxRequest& request, ::krserver::ServerMessageBoxResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::krserver::ServerMessageBoxRequest, ::krserver::ServerMessageBoxResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ServerMessageBox_, context, request, response);
}

void KrConnectionApi::Stub::async::ServerMessageBox(::grpc::ClientContext* context, const ::krserver::ServerMessageBoxRequest* request, ::krserver::ServerMessageBoxResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::krserver::ServerMessageBoxRequest, ::krserver::ServerMessageBoxResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ServerMessageBox_, context, request, response, std::move(f));
}

void KrConnectionApi::Stub::async::ServerMessageBox(::grpc::ClientContext* context, const ::krserver::ServerMessageBoxRequest* request, ::krserver::ServerMessageBoxResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ServerMessageBox_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::krserver::ServerMessageBoxResponse>* KrConnectionApi::Stub::PrepareAsyncServerMessageBoxRaw(::grpc::ClientContext* context, const ::krserver::ServerMessageBoxRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::krserver::ServerMessageBoxResponse, ::krserver::ServerMessageBoxRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ServerMessageBox_, context, request);
}

::grpc::ClientAsyncResponseReader< ::krserver::ServerMessageBoxResponse>* KrConnectionApi::Stub::AsyncServerMessageBoxRaw(::grpc::ClientContext* context, const ::krserver::ServerMessageBoxRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncServerMessageBoxRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status KrConnectionApi::Stub::ServerTaskEndAndEnableUI(::grpc::ClientContext* context, const ::krserver::ServerTaskEndAndEnableUIRequest& request, ::krserver::ServerTaskEndAndEnableUIResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::krserver::ServerTaskEndAndEnableUIRequest, ::krserver::ServerTaskEndAndEnableUIResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ServerTaskEndAndEnableUI_, context, request, response);
}

void KrConnectionApi::Stub::async::ServerTaskEndAndEnableUI(::grpc::ClientContext* context, const ::krserver::ServerTaskEndAndEnableUIRequest* request, ::krserver::ServerTaskEndAndEnableUIResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::krserver::ServerTaskEndAndEnableUIRequest, ::krserver::ServerTaskEndAndEnableUIResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ServerTaskEndAndEnableUI_, context, request, response, std::move(f));
}

void KrConnectionApi::Stub::async::ServerTaskEndAndEnableUI(::grpc::ClientContext* context, const ::krserver::ServerTaskEndAndEnableUIRequest* request, ::krserver::ServerTaskEndAndEnableUIResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ServerTaskEndAndEnableUI_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::krserver::ServerTaskEndAndEnableUIResponse>* KrConnectionApi::Stub::PrepareAsyncServerTaskEndAndEnableUIRaw(::grpc::ClientContext* context, const ::krserver::ServerTaskEndAndEnableUIRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::krserver::ServerTaskEndAndEnableUIResponse, ::krserver::ServerTaskEndAndEnableUIRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ServerTaskEndAndEnableUI_, context, request);
}

::grpc::ClientAsyncResponseReader< ::krserver::ServerTaskEndAndEnableUIResponse>* KrConnectionApi::Stub::AsyncServerTaskEndAndEnableUIRaw(::grpc::ClientContext* context, const ::krserver::ServerTaskEndAndEnableUIRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncServerTaskEndAndEnableUIRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status KrConnectionApi::Stub::ServerTaskStartAndDisableUI(::grpc::ClientContext* context, const ::krserver::ServerTaskStartAndDisableUIRequest& request, ::krserver::ServerTaskStartAndDisableUIResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::krserver::ServerTaskStartAndDisableUIRequest, ::krserver::ServerTaskStartAndDisableUIResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ServerTaskStartAndDisableUI_, context, request, response);
}

void KrConnectionApi::Stub::async::ServerTaskStartAndDisableUI(::grpc::ClientContext* context, const ::krserver::ServerTaskStartAndDisableUIRequest* request, ::krserver::ServerTaskStartAndDisableUIResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::krserver::ServerTaskStartAndDisableUIRequest, ::krserver::ServerTaskStartAndDisableUIResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ServerTaskStartAndDisableUI_, context, request, response, std::move(f));
}

void KrConnectionApi::Stub::async::ServerTaskStartAndDisableUI(::grpc::ClientContext* context, const ::krserver::ServerTaskStartAndDisableUIRequest* request, ::krserver::ServerTaskStartAndDisableUIResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ServerTaskStartAndDisableUI_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::krserver::ServerTaskStartAndDisableUIResponse>* KrConnectionApi::Stub::PrepareAsyncServerTaskStartAndDisableUIRaw(::grpc::ClientContext* context, const ::krserver::ServerTaskStartAndDisableUIRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::krserver::ServerTaskStartAndDisableUIResponse, ::krserver::ServerTaskStartAndDisableUIRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ServerTaskStartAndDisableUI_, context, request);
}

::grpc::ClientAsyncResponseReader< ::krserver::ServerTaskStartAndDisableUIResponse>* KrConnectionApi::Stub::AsyncServerTaskStartAndDisableUIRaw(::grpc::ClientContext* context, const ::krserver::ServerTaskStartAndDisableUIRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncServerTaskStartAndDisableUIRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status KrConnectionApi::Stub::ServerUIHeartbeatPackage(::grpc::ClientContext* context, const ::krserver::ServerUIHeartbeatPackageRequest& request, ::krserver::ServerUIHeartbeatPackageResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::krserver::ServerUIHeartbeatPackageRequest, ::krserver::ServerUIHeartbeatPackageResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ServerUIHeartbeatPackage_, context, request, response);
}

void KrConnectionApi::Stub::async::ServerUIHeartbeatPackage(::grpc::ClientContext* context, const ::krserver::ServerUIHeartbeatPackageRequest* request, ::krserver::ServerUIHeartbeatPackageResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::krserver::ServerUIHeartbeatPackageRequest, ::krserver::ServerUIHeartbeatPackageResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ServerUIHeartbeatPackage_, context, request, response, std::move(f));
}

void KrConnectionApi::Stub::async::ServerUIHeartbeatPackage(::grpc::ClientContext* context, const ::krserver::ServerUIHeartbeatPackageRequest* request, ::krserver::ServerUIHeartbeatPackageResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ServerUIHeartbeatPackage_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::krserver::ServerUIHeartbeatPackageResponse>* KrConnectionApi::Stub::PrepareAsyncServerUIHeartbeatPackageRaw(::grpc::ClientContext* context, const ::krserver::ServerUIHeartbeatPackageRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::krserver::ServerUIHeartbeatPackageResponse, ::krserver::ServerUIHeartbeatPackageRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ServerUIHeartbeatPackage_, context, request);
}

::grpc::ClientAsyncResponseReader< ::krserver::ServerUIHeartbeatPackageResponse>* KrConnectionApi::Stub::AsyncServerUIHeartbeatPackageRaw(::grpc::ClientContext* context, const ::krserver::ServerUIHeartbeatPackageRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncServerUIHeartbeatPackageRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status KrConnectionApi::Stub::ServerUIReady(::grpc::ClientContext* context, const ::krserver::ServerUIReadyRequest& request, ::krserver::ServerUIReadyResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::krserver::ServerUIReadyRequest, ::krserver::ServerUIReadyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ServerUIReady_, context, request, response);
}

void KrConnectionApi::Stub::async::ServerUIReady(::grpc::ClientContext* context, const ::krserver::ServerUIReadyRequest* request, ::krserver::ServerUIReadyResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::krserver::ServerUIReadyRequest, ::krserver::ServerUIReadyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ServerUIReady_, context, request, response, std::move(f));
}

void KrConnectionApi::Stub::async::ServerUIReady(::grpc::ClientContext* context, const ::krserver::ServerUIReadyRequest* request, ::krserver::ServerUIReadyResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ServerUIReady_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::krserver::ServerUIReadyResponse>* KrConnectionApi::Stub::PrepareAsyncServerUIReadyRaw(::grpc::ClientContext* context, const ::krserver::ServerUIReadyRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::krserver::ServerUIReadyResponse, ::krserver::ServerUIReadyRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ServerUIReady_, context, request);
}

::grpc::ClientAsyncResponseReader< ::krserver::ServerUIReadyResponse>* KrConnectionApi::Stub::AsyncServerUIReadyRaw(::grpc::ClientContext* context, const ::krserver::ServerUIReadyRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncServerUIReadyRaw(context, request, cq);
  result->StartCall();
  return result;
}

KrConnectionApi::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      KrConnectionApi_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< KrConnectionApi::Service, ::krserver::ServerProgressBarRequest, ::krserver::ServerProgressBarResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](KrConnectionApi::Service* service,
             ::grpc::ServerContext* ctx,
             const ::krserver::ServerProgressBarRequest* req,
             ::krserver::ServerProgressBarResponse* resp) {
               return service->ServerProgressBar(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      KrConnectionApi_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< KrConnectionApi::Service, ::krserver::ServerCommandResultOutputRequest, ::krserver::ServerCommandResultOutputResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](KrConnectionApi::Service* service,
             ::grpc::ServerContext* ctx,
             const ::krserver::ServerCommandResultOutputRequest* req,
             ::krserver::ServerCommandResultOutputResponse* resp) {
               return service->ServerCommandResultOutput(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      KrConnectionApi_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< KrConnectionApi::Service, ::krserver::ServerExitFromRemoteProcessRequest, ::krserver::ServerExitFromRemoteProcessResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](KrConnectionApi::Service* service,
             ::grpc::ServerContext* ctx,
             const ::krserver::ServerExitFromRemoteProcessRequest* req,
             ::krserver::ServerExitFromRemoteProcessResponse* resp) {
               return service->ServerExitFromRemoteProcess(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      KrConnectionApi_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< KrConnectionApi::Service, ::krserver::ServerLogOutputRequest, ::krserver::ServerLogOutputResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](KrConnectionApi::Service* service,
             ::grpc::ServerContext* ctx,
             const ::krserver::ServerLogOutputRequest* req,
             ::krserver::ServerLogOutputResponse* resp) {
               return service->ServerLogOutput(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      KrConnectionApi_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< KrConnectionApi::Service, ::krserver::ServerMessageBoxRequest, ::krserver::ServerMessageBoxResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](KrConnectionApi::Service* service,
             ::grpc::ServerContext* ctx,
             const ::krserver::ServerMessageBoxRequest* req,
             ::krserver::ServerMessageBoxResponse* resp) {
               return service->ServerMessageBox(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      KrConnectionApi_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< KrConnectionApi::Service, ::krserver::ServerTaskEndAndEnableUIRequest, ::krserver::ServerTaskEndAndEnableUIResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](KrConnectionApi::Service* service,
             ::grpc::ServerContext* ctx,
             const ::krserver::ServerTaskEndAndEnableUIRequest* req,
             ::krserver::ServerTaskEndAndEnableUIResponse* resp) {
               return service->ServerTaskEndAndEnableUI(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      KrConnectionApi_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< KrConnectionApi::Service, ::krserver::ServerTaskStartAndDisableUIRequest, ::krserver::ServerTaskStartAndDisableUIResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](KrConnectionApi::Service* service,
             ::grpc::ServerContext* ctx,
             const ::krserver::ServerTaskStartAndDisableUIRequest* req,
             ::krserver::ServerTaskStartAndDisableUIResponse* resp) {
               return service->ServerTaskStartAndDisableUI(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      KrConnectionApi_method_names[7],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< KrConnectionApi::Service, ::krserver::ServerUIHeartbeatPackageRequest, ::krserver::ServerUIHeartbeatPackageResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](KrConnectionApi::Service* service,
             ::grpc::ServerContext* ctx,
             const ::krserver::ServerUIHeartbeatPackageRequest* req,
             ::krserver::ServerUIHeartbeatPackageResponse* resp) {
               return service->ServerUIHeartbeatPackage(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      KrConnectionApi_method_names[8],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< KrConnectionApi::Service, ::krserver::ServerUIReadyRequest, ::krserver::ServerUIReadyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](KrConnectionApi::Service* service,
             ::grpc::ServerContext* ctx,
             const ::krserver::ServerUIReadyRequest* req,
             ::krserver::ServerUIReadyResponse* resp) {
               return service->ServerUIReady(ctx, req, resp);
             }, this)));
}

KrConnectionApi::Service::~Service() {
}

::grpc::Status KrConnectionApi::Service::ServerProgressBar(::grpc::ServerContext* context, const ::krserver::ServerProgressBarRequest* request, ::krserver::ServerProgressBarResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status KrConnectionApi::Service::ServerCommandResultOutput(::grpc::ServerContext* context, const ::krserver::ServerCommandResultOutputRequest* request, ::krserver::ServerCommandResultOutputResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status KrConnectionApi::Service::ServerExitFromRemoteProcess(::grpc::ServerContext* context, const ::krserver::ServerExitFromRemoteProcessRequest* request, ::krserver::ServerExitFromRemoteProcessResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status KrConnectionApi::Service::ServerLogOutput(::grpc::ServerContext* context, const ::krserver::ServerLogOutputRequest* request, ::krserver::ServerLogOutputResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status KrConnectionApi::Service::ServerMessageBox(::grpc::ServerContext* context, const ::krserver::ServerMessageBoxRequest* request, ::krserver::ServerMessageBoxResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status KrConnectionApi::Service::ServerTaskEndAndEnableUI(::grpc::ServerContext* context, const ::krserver::ServerTaskEndAndEnableUIRequest* request, ::krserver::ServerTaskEndAndEnableUIResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status KrConnectionApi::Service::ServerTaskStartAndDisableUI(::grpc::ServerContext* context, const ::krserver::ServerTaskStartAndDisableUIRequest* request, ::krserver::ServerTaskStartAndDisableUIResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status KrConnectionApi::Service::ServerUIHeartbeatPackage(::grpc::ServerContext* context, const ::krserver::ServerUIHeartbeatPackageRequest* request, ::krserver::ServerUIHeartbeatPackageResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status KrConnectionApi::Service::ServerUIReady(::grpc::ServerContext* context, const ::krserver::ServerUIReadyRequest* request, ::krserver::ServerUIReadyResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace krserver

